{"version":3,"sources":["../util/math.ts","gl-util.ts","mouse-orbit.ts","../csg/glsl-util.ts","../csg/boolean.ts","../csg/manipulate.ts","../csg/extrude.ts","../csg/primitives.ts","sample.ts","entry.ts"],"names":[],"mappings":"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","file":"entry.9c717ee6.js","sourceRoot":"..\\..\\..\\src\\viewer","sourcesContent":["\n// some basic vector maths\nexport class Vector<T extends number[]>{\n  result: T;\n  constructor(v: T) {\n    this.result = v;\n  }\n\n  minus(v: T) {\n    const a = [] as T;\n    for (let i in this.result) {\n      a[i] = this.result[i] - v[i];\n    }\n    this.result = a;\n    return this;\n  }\n  dot(v: T) {\n    let sum = 0;\n    for (let i in this.result) {\n      sum += this.result[i] * v[i];\n    }\n    return sum;\n  }\n\n  add(v: T) {\n    const a = [] as T;\n    for (let i in this.result) {\n      a[i] = this.result[i] + v[i];\n    }\n    this.result = a;\n    return this;\n  }\n  scale(s: number) {\n    const a = [] as T;\n    for (let i in this.result) {\n      a[i] = this.result[i] * s;\n    }\n    this.result = a;\n    return this;\n  }\n\n  cross2d(v: Vec2) {\n    return this.result[0] * v[1] - this.result[1] * v[0];\n  }\n\n  cross(v: Vec3) {\n    const a = [0, 0, 0] as T;\n    a[0] = this.result[1] * v[2] - this.result[2] * v[1];\n    a[1] = this.result[2] * v[0] - this.result[0] * v[2];\n    a[2] = this.result[0] * v[1] - this.result[1] * v[0];\n    this.result = a;\n    return this;\n  }\n\n  toUnitVector() {\n    const mag = this.magnitude();\n    return this.scale(1 / mag);\n  }\n\n  magnitude() {\n    let sum = 0;\n    for (let v of this.result) {\n      sum += v * v;\n    }\n    return Math.sqrt(sum);\n  }\n}\n\nexport function getSurfaceNormal(p: Vec3, fn: Shape3): Vector<Vec3> {\n  const h = 0.001\n  const val = fn(p);\n  const [x, y, z] = p;\n  return new Vector([\n    fn([x + h, y, z]) - val,\n    fn([x, y + h, z]) - val,\n    fn([x, y, z + h]) - val\n  ] as Vec3).toUnitVector();\n}\n\n// return x between a and b\nexport function clamp(x: number, a: number, b: number) {\n  if (x < a) {\n    return a;\n  } else if (x > b) {\n    return b;\n  } else {\n    return x;\n  }\n}\n\n// s between 0 and 1, \n// returns the linear interpolation between a and b\nexport function mix(a: number, b: number, s: number) {\n  return a * (1 - s) + b * s;\n}\n\nexport const getHex: (n: number) => string = (() => {\n  const buffer = new ArrayBuffer(4);\n  const intView = new Int32Array(buffer);\n  const floatView = new Float32Array(buffer);\n\n  return (n: number) => {\n    floatView[0] = n;\n    return intView[0].toString(16);\n  }\n})();\n\nexport const positiveNumReducer = (a: number, v: number, i: number) => {\n  if (v > 0) {\n    a |= 1 << i;\n  }\n  return a;\n}\n\nexport const boundsToCorners = ([[a, b, c], [x, y, z]]: Bounds) => [\n  [a, b, c], [x, b, c], [a, y, c], [x, y, c],\n  [a, b, z], [x, b, z], [a, y, z], [x, y, z]\n] as Cube;\n\nexport const boundsToCorners2 = ([[a, b], [x, y]]: Bounds2) => [\n  [a, b], [x, b], [a, y], [x, y],\n] as Square;\n\nexport const getCentroid = (t: Vec3[]) => {\n  const sum = t.reduce((a, v) => [a[0] + v[0], a[1] + v[1], a[2] + v[2]], [0, 0, 0]);\n  return sum.map(p => p / 3) as Vec3;\n}\n\nexport const getCenter = <T extends Vec2 | Vec3>(p1: T, p2: T) =>\n  new Vector(p1).add(p2).scale(1 / 2).result as T;\n\nexport const splitCube = (cube: Cube): Cube[] => {\n  const center = getCenter(cube[0], cube[7]) as Vec3;\n  const c0 = boundsToCorners([cube[0], center]);\n  const c7 = boundsToCorners([center, cube[7]]);\n  const c1 = boundsToCorners([c0[1], c7[1]]);\n  const c2 = boundsToCorners([c0[2], c7[2]]);\n  const c3 = boundsToCorners([c0[3], c7[3]]);\n  const c4 = boundsToCorners([c0[4], c7[4]]);\n  const c5 = boundsToCorners([c0[5], c7[5]]);\n  const c6 = boundsToCorners([c0[6], c7[6]]);\n  return [c0, c1, c2, c3, c4, c5, c6, c7];\n}\nexport const splitSquare = (square: Square): Square[] => {\n  const center = getCenter(square[0], square[3]) as Vec2;\n  const c0 = boundsToCorners2([square[0], center]);\n  const c3 = boundsToCorners2([center, square[3]]);\n  const c1 = boundsToCorners2([c0[1], c3[1]]);\n  const c2 = boundsToCorners2([c0[2], c3[2]]);\n  return [c0, c1, c2, c3];\n}\n\nexport const interpolate = <T extends Vec2 | Vec3>(p1: T, p2: T, e1: number, e2: number): T => {\n  const diff = new Vector(p2).minus(p1);\n  const abs_e1 = Math.abs(e1);\n  const abs_e2 = Math.abs(e2);\n  return diff.scale(abs_e1 / (abs_e1 + abs_e2)).add(p1).result;\n}\n\nexport const findZeroRecursive = <T extends Vec2 | Vec3>(p1: T, p2: T, e1: number, e2: number, threshold: number, fn: (t: T) => number): T => {\n  const center = getCenter(p1, p2);\n  const val = fn(center);\n  if (Math.abs(val) < threshold) {\n    return center;\n  } else if (Math.sign(e1) !== Math.sign(val)) {\n    return findZeroRecursive(p1, center, e1, val, threshold, fn);\n  } else {\n    return findZeroRecursive(center, p2, val, e2, threshold, fn);\n  }\n}","export const initialState = {\r\n  iResolution: [600, 600, 1] as Vec3,\r\n  cameraPos: [0, 0, -80] as Vec3,\r\n  cameraDir: [0, 0, 1] as Vec3,\r\n  cameraTop: [0, 1, 0] as Vec3,\r\n  zoom: 4\r\n};\r\n\r\nexport type State = typeof initialState;\r\nexport type ShaderSrc = {\r\n  entry: string,\r\n  funcs: string[]\r\n}\r\n\r\nexport const fragmentShaderSrc = ({ entry, funcs }: ShaderSrc) => `\r\nprecision highp float;\r\n\r\nuniform vec3 iResolution;\r\nuniform vec3 cameraPos;\r\nuniform vec3 cameraDir;\r\nuniform vec3 cameraTop;\r\nuniform float zoom;\r\n\r\n#define MAX_STEPS 100\r\n#define MAX_DIST 1000.\r\n#define SURF_DIST .01\r\n\r\n${funcs.join('\\n')}\r\n\r\nfloat GetDist(vec3 p) {\r\n  return ${entry}(p);\r\n}\r\n\r\nfloat RayMarch(vec3 ro, vec3 rd) {\r\n\tfloat dO=0.;\r\n    \r\n  for(int i=0; i<MAX_STEPS; i++) {\r\n    vec3 p = ro + rd*dO;\r\n    float dS = GetDist(p);\r\n    dO += dS;\r\n    if(dO>MAX_DIST || dS<SURF_DIST) break;\r\n  }\r\n    \r\n  return dO;\r\n}\r\n\r\nvec3 GetNormal(vec3 p) {\r\n\tfloat d = GetDist(p);\r\n  vec2 e = vec2(.01, 0);\r\n  \r\n  vec3 n = d - vec3(\r\n    GetDist(p-e.xyy),\r\n    GetDist(p-e.yxy),\r\n    GetDist(p-e.yyx));\r\n    \r\n  return normalize(n);\r\n}\r\n\r\nfloat GetLight(vec3 p) {\r\n  vec3 lightPos = cameraPos;\r\n  lightPos.xz += vec2(0,1)*2.;\r\n  vec3 l = normalize(lightPos-p);\r\n  vec3 n = GetNormal(p);\r\n  float dif = dot(n, l);\r\n  return dif;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\r\n  vec2 uv = fragCoord/iResolution.xy;\r\n  uv = uv * 2. - 1.;\r\n  vec3 col = vec3(0);\r\n  vec3 ro = cameraPos;\r\n  vec3 r = cross(cameraDir,cameraTop);\r\n\r\n  vec3 rd = normalize(cameraDir*zoom+ uv.x*r + uv.y*cameraTop);\r\n\r\n  float d = RayMarch(ro, rd);\r\n  if (d >= MAX_DIST){\r\n    fragColor = vec4(.5,.5,1,1);\r\n    return;\r\n  }\r\n    \r\n  vec3 p = ro + rd * d; \r\n  float dif = GetLight(p);\r\n  col = vec3(dif);\r\n  fragColor = vec4(col,1.0);\r\n}\r\n\r\nvoid main() {\r\n  mainImage(gl_FragColor, gl_FragCoord.xy);\r\n}\r\n\r\n`;\r\n\r\nexport const vertexShaderSrc = `\r\n\t// vertex shader's code goes here\r\n  attribute vec2 position;\r\n  void main() {\r\n    gl_Position = vec4(position, 0.0, 1.0);  \r\n  } \r\n`;\r\n\r\nexport const setupWebGL = (canvas: HTMLCanvasElement, src: ShaderSrc) => {\r\n\r\n  const gl = canvas.getContext(\"webgl\");\r\n  gl.clearColor(0, 0, 0, 1);\r\n  gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n  var vertexShader = gl.createShader(gl.VERTEX_SHADER);\r\n  gl.shaderSource(vertexShader, vertexShaderSrc);\r\n  gl.compileShader(vertexShader);\r\n  console.log(gl.getShaderInfoLog(vertexShader));\r\n\r\n  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\r\n  const fragmentSrc = fragmentShaderSrc(src);\r\n  console.log(fragmentSrc);\r\n  gl.shaderSource(fragmentShader, fragmentSrc);\r\n  gl.compileShader(fragmentShader);\r\n  console.log(gl.getShaderInfoLog(fragmentShader));\r\n\r\n  var program = gl.createProgram();\r\n  gl.attachShader(program, vertexShader);\r\n  gl.attachShader(program, fragmentShader);\r\n  gl.linkProgram(program);\r\n\r\n  var vertices = new Float32Array([\r\n    -1, -1, -1, 1, 1, 1,\r\n    -1, -1, 1, -1, 1, 1,\r\n  ]);\r\n\r\n  var buffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\r\n\r\n  gl.useProgram(program);\r\n  const glVars: any = {};\r\n  Object.keys(initialState).forEach(key => {\r\n    console.log('locating', key);\r\n    glVars[key] = gl.getUniformLocation(program, key);\r\n  });\r\n\r\n\r\n  const position = gl.getAttribLocation(program, 'position');\r\n  gl.enableVertexAttribArray(position);\r\n  gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);\r\n\r\n\r\n  const setState = (state: State) => {\r\n    // set bindings\r\n    Object.entries(state).forEach(([key, val]) => {\r\n      if (val instanceof Array) {\r\n        switch (val.length) {\r\n          // case 1:\r\n          //   gl.uniform1fv(glVars[key], val);\r\n          //   break;\r\n          // case 2:\r\n          //   gl.uniform2fv(glVars[key], val);\r\n          //   break;\r\n          case 3:\r\n            gl.uniform3fv(glVars[key], val);\r\n            break;\r\n          // case 4:\r\n          //   gl.uniform4fv(glVars[key], val);\r\n          //   break;\r\n          default:\r\n            throw 'unable to accomodate larger than 4 entries';\r\n        }\r\n      } else {\r\n        gl.uniform1f(glVars[key], val);\r\n      }\r\n      //console.log('setting', key, val);\r\n    });\r\n\r\n    // draw\r\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n  }\r\n  setState(initialState);\r\n  return setState;\r\n}","import { clamp, Vector } from \"../util/math\";\r\nimport * as _ from 'lodash';\r\n\r\nexport type ClickAndDragCB = {\r\n  current: Vec2;\r\n  startPos: Vec2;\r\n  end: boolean;\r\n  leftClick: boolean;\r\n}\r\nexport const registerClickAndDrag = (el: HTMLElement, cb: (p: ClickAndDragCB) => void) => {\r\n  let mouseListen = false;\r\n  let startPos: Vec2 = [null, null];\r\n  let leftClick: boolean = null;\r\n\r\n  const start = (e: MouseEvent) => {\r\n    mouseListen = true;\r\n    startPos = [e.clientX, e.clientY];\r\n    leftClick = e.button === 0;\r\n  }\r\n  const stop = (e: MouseEvent) => {\r\n    if (mouseListen) {\r\n      mouseListen = false\r\n      const current: Vec2 = [e.clientX, e.clientY];\r\n      cb({ current, startPos, end: true, leftClick });\r\n      leftClick = null\r\n    }\r\n  }\r\n  const moving = (e: MouseEvent) => {\r\n    if (mouseListen) {\r\n      const current: Vec2 = [e.clientX, e.clientY];\r\n      cb({ current, startPos, end: false, leftClick });\r\n    }\r\n  }\r\n\r\n  el.addEventListener('mousedown', start);\r\n  el.addEventListener('mouseup', stop);\r\n  el.addEventListener('mouseout', stop);\r\n  el.addEventListener('mousemove', moving);\r\n}\r\n\r\nexport const registerScrollWheel = (el: HTMLElement, cb: (zoom: number) => void) => {\r\n  el.addEventListener('wheel', (e => {\r\n    cb(e.deltaY);\r\n  }));\r\n}\r\n\r\nexport type SphericalSystem = {\r\n  pos: Vec3, //[r,theta,phi]\r\n  origin: Vec3,  //\r\n}\r\nexport type CartesianSystem = {\r\n  cameraPos: Vec3,\r\n  cameraDir?: Vec3, // undefined when camera is at origin\r\n  cameraTop?: Vec3 // undefined when camera is facing up/down exacltly\r\n}\r\nexport const sphericalToCartesion = ({ pos: [radius, theta, _phi], origin }: SphericalSystem): CartesianSystem => {\r\n  if (Math.abs(radius) < 0.01) {\r\n    return {\r\n      cameraPos: origin\r\n    }\r\n  }\r\n  const phi = clamp(_phi, -Math.PI + .01, Math.PI - .01);\r\n\r\n  const xzRadius = radius * Math.cos(phi);\r\n\r\n  const cameraPos: Vec3 = [\r\n    xzRadius * Math.sin(theta) + origin[0],\r\n    radius * Math.sin(phi) + origin[2],\r\n    -xzRadius * Math.cos(theta) + origin[1],\r\n  ];\r\n  const cameraDir = new Vector(origin).minus(cameraPos).toUnitVector().result as Vec3;\r\n\r\n  const up: Vec3 = [0, 1, 0];\r\n\r\n  const cameraTop = new Vector(cameraDir).cross(up).cross(cameraDir).toUnitVector().result;\r\n\r\n  return {\r\n    cameraPos,\r\n    cameraDir,\r\n    cameraTop\r\n  };\r\n};\r\n","import { ShaderSrc } from \"../viewer/gl-util\";\r\n\r\n// used for format floats suchs that 1 will show as 1.0\r\nexport const f = (n: number) => n.toLocaleString('en-US', {\r\n  minimumFractionDigits: 1,\r\n  useGrouping: false\r\n});\r\nexport const v3 = (p: Vec3) => `vec3(${f(p[0])},${f(p[1])},${f(p[2])})`;\r\n\r\nlet count = 0;\r\nexport const addFunc = (type: string, args: string, def: string, deps: GLNode[]): GLNode => {\r\n  const name = `fn${count++}`;\r\n  const body = deps.reduce((a, v, i) => a.replace(new RegExp('\\\\$' + (i + 1), 'g'), v.name), def);\r\n  const src = `${type} ${name}(${args}){\\n${body}\\n}`;\r\n  return { name, src, deps };\r\n}\r\n\r\n\r\nexport const wrap = (fn: (p: Vec3) => number, type: string, args: string, def: string, deps: GLNode[]): Shape3 => {\r\n  const fns = fn as Shape3;\r\n  fns.gl = addFunc(type, args, def, deps);\r\n  return fns;\r\n}\r\n\r\nconst walkSrc = (n: GLNode): string[] => [...n.deps.flatMap(walkSrc), n.src];\r\nexport const getShaderSrc = (n: GLNode): ShaderSrc => {\r\n  const funcs = walkSrc(n);\r\n  return {\r\n    entry: n.name,\r\n    funcs\r\n  };\r\n}","import { clamp, mix, Vector } from \"../util/math\";\nimport { addFunc, f } from \"./glsl-util\";\n\ntype Ops = 'union' | 'diff' | 'intersect';\nconst ops: { [key in Ops]: (s1: Shape3, s2: Shape3) => Shape3 } = {\n  union: (s1: Shape3, s2: Shape3): Shape3 => {\n    const sp = (p: Vec3) => {\n      return Math.min(s1(p), s2(p));\n    };\n    sp.gl = addFunc('float', 'vec3 p', `return min($1(p),$2(p))`, [s1.gl, s2.gl]);\n    return sp;\n  },\n  diff: (s1: Shape3, s2: Shape3): Shape3 => {\n    const sp = (p: Vec3) => {\n      return Math.min(s1(p), -s2(p));\n    };\n    sp.gl = addFunc('float', 'vec3 p', `return max($1(p),-$2(p))`, [s1.gl, s2.gl]);\n    return sp;\n  },\n  intersect: (s1: Shape3, s2: Shape3): Shape3 => {\n    const sp = (p: Vec3) => {\n      return Math.max(s1(p), s2(p));\n    };\n    sp.gl = addFunc('float', 'vec3 p', `return max($1(p),$2(p))`, [s1.gl, s2.gl]);\n    return sp;\n  }\n};\nconst roundOps: { [key in Ops]: (r: number, s1: Shape3, s2: Shape3) => Shape3 } = {\n  union: (radius: number, s1: Shape3, s2: Shape3): Shape3 => {\n    const sp = (p: Vec3) => {\n      const p1 = s1(p);\n      const p2 = s2(p);\n      const h = clamp(0.5 + 0.5 * (p2 - p1) / radius, 0, 1);\n      return mix(p2, p1, h) - radius * h * (1 - h);\n    };\n    sp.gl = addFunc('float', 'vec3 p', [\n      `float k = ${f(radius)};`,\n      `float d1 = $1(p);`,\n      `float d2 = $2(p);`,\n      `float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );`,\n      `return mix( d2, d1, h ) - k*h*(1.0-h);`\n    ].join('\\n'), [s1.gl, s2.gl]);\n    return sp;\n  },\n  diff: (radius: number, s1: Shape3, s2: Shape3): Shape3 => {\n    const sp = (p: Vec3) => {\n      const p1 = s1(p);\n      const p2 = s2(p);\n      const h = clamp(0.5 - 0.5 * (p1 + p2) / radius, 0, 1);\n      return mix(p1, -p2, h) + radius * h * (1 - h);\n    };\n    sp.gl = addFunc('float', 'vec3 p', [\n      `float k = ${f(radius)};`,\n      `float d1 = $1(p);`,\n      `float d2 = $2(p);`,\n      `float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );`,\n      `return mix( d2, -d1, h ) + k*h*(1.0-h);`\n    ].join('\\n'), [s2.gl, s2.gl]);\n    return sp;\n  },\n  intersect: (radius: number, s1: Shape3, s2: Shape3): Shape3 => {\n    const sp = (p: Vec3) => {\n      const p1 = s1(p);\n      const p2 = s2(p);\n      const h = clamp(0.5 - 0.5 * (p2 - p1) / radius, 0, 1);\n      return mix(p2, p1, h) + radius * h * (1 - h);\n    };\n    sp.gl = addFunc('float', 'vec3 p', [\n      `float k = ${f(radius)};`,\n      `float d1 = $1(p);`,\n      `float d2 = $2(p);`,\n      `float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );`,\n      `return mix( d2, d1, h ) + k*h*(1.0-h);`\n    ].join('\\n'), [s1.gl, s2.gl]);\n    return sp;\n  }\n};\n\n\ntype OpParams = {\n  radius: number;\n}\nconst opRouter = (op: Ops) => (a: OpParams | Shape3, ...s: Shape3[]) => {\n  const shapes: Shape3[] = [];\n  let radius = 0;\n\n  // normalize arguments\n  if ('radius' in a) {\n    radius = a.radius;\n  } else {\n    shapes.push(a);\n  }\n  shapes.push(...s);\n\n  // check arguments\n  if (shapes.length === 0) {\n    throw `${op} requires 2 or more shapes`;\n  } else if (shapes.length === 1) {\n    return shapes[0];\n  }\n\n  const [head, ...rest] = shapes;\n  if (radius && radius > 0) {\n    return rest.reduce((a, v, i) => roundOps[op](radius, a, v), head);\n  } else {\n    return rest.reduce((a, v, i) => ops[op](a, v), head);\n  }\n}\nexport const union = opRouter('union');\nexport const diff = opRouter('diff');\nexport const intersect = opRouter('intersect');\n\n\n","import { wrap, v3, f, addFunc } from \"./glsl-util\";\n\nexport function translate(translation: Vec3, s: Shape3): Shape3 {\n  const fn = (v: number, i: number) => v - translation[i];\n  const sp = (p: Vec3) => s(p.map(fn) as Vec3);\n  sp.gl = addFunc('float', 'vec3 p', `return $1(p-${v3(translation)});`, [s.gl]);\n  return sp;\n}\n\nexport function rotate(axis: Axis, degrees: number, s: Shape3): Shape3 {\n  const sn = Math.sin(degrees * 2 * Math.PI / 360);\n  const cs = Math.cos(degrees * 2 * Math.PI / 360);\n\n  switch (axis) {\n    case 'x': return wrap(\n      ([x, y, z]) => s([x, y * cs - z * sn, y * sn + z * cs]), 'float', 'vec3 p',\n      `return ($1(vec3(p.x,p.y*${f(cs)}-p.z*${f(sn)},p.y*${f(sn)}+p.z*${f(cs)})));`, [s.gl]);\n    case 'y': return wrap(\n      ([x, y, z]) => s([x * cs + z * sn, y, z * cs - x * sn]), 'float', 'vec3 p',\n      `return ($1(vec3(p.x*${f(cs)}+p.z*${f(sn)},p.y,p.z*${f(cs)}-p.x*${f(sn)})));`, [s.gl]);\n    case 'z': return wrap(\n      ([x, y, z]) => s([x * cs - y * sn, x * sn + y * cs, z]), 'float', 'vec3 p',\n      `return ($1(vec3(p.x*${f(cs)}-p.y*${f(sn)},p.x*${f(sn)}+p.y*${f(cs)},p.z)));`, [s.gl]);\n  }\n}\n\nexport function scale(d: number, s: Shape3): Shape3 {\n  const sc = (a: number) => a / d;\n  const sp = (p: Vec3) => s(p.map(sc) as Vec3) * d;\n  sp.gl = addFunc('float', 'vec3 p', `return $1(p/${f(d)})*${f(d)};`, [s.gl]);\n  return sp;\n}","import { clamp, Vector } from \"../util/math\";\nimport { addFunc, f, wrap } from \"./glsl-util\";\n\nexport function extrude(height: number, s: Shape2): Shape3 {\n  const h = height / 2;\n  const sp = (p: Vec3) => {\n    const d = s([p[0], p[1]]);\n    const w = Math.abs(p[2]) - h;\n\n    const outside = new Vector([Math.max(d, 0), Math.max(w, 0)]).magnitude();\n    const inside = Math.min(Math.max(d, w), 0);\n    return outside + inside;\n  }\n  sp.gl = addFunc('float', 'vec3 p', [\n    `float d = ${s.gl.name}(p.xy);`,\n    `vec2 w = vec2( d, abs(p.z) - ${f(h)} );`,\n    `return min(max(w.x,w.y),0.0) + length(max(w,0.0));`\n  ].join('\\n'), [s.gl]);\n  return sp;\n}\n\n\nexport function revolve(axis: Axis, offset: number, s: Shape2): Shape3 {\n  switch (axis) {\n    case 'x': return wrap((p) => s([new Vector([p[1], p[2]]).magnitude() - offset, p[0]]),\n      'float', 'vec3 p', `return $1(length(p.yz)-${f(offset)},p.x)`, [s.gl]);\n    case 'y': return wrap((p) => s([new Vector([p[0], p[2]]).magnitude() - offset, p[1]]),\n      'float', 'vec3 p', `return $1(length(p.xz)-${f(offset)},p.y)`, [s.gl]);\n    case 'z': return wrap((p) => s([new Vector([p[0], p[1]]).magnitude() - offset, p[2]]),\n      'float', 'vec3 p', `return $1(length(p.xy)-${f(offset)},p.z)`, [s.gl]);\n  }\n}\n\nexport function mirror(plane: Plane, s: Shape3): Shape3 {\n  switch (plane) {\n    case 'yz': return wrap(\n      (p) => s([Math.abs(p[0]), p[1], p[2]]),\n      'float', 'vec3 p', `return $1(vec3(abs(p.x),p.y,p.z));`, [s.gl]);\n    case 'xy': return wrap(\n      (p) => s([p[0], p[1], Math.abs(p[2])]),\n      'float', 'vec3 p', `return $1(vec3(p.x,p.y,abs(p.z)));`, [s.gl]);\n    case 'xz': return wrap(\n      (p) => s([p[0], Math.abs(p[1]), p[2]]),\n      'float', 'vec3 p', `return $1(vec3(p.x,abs(p.y),p.z));`, [s.gl]);\n  }\n}\n\n// tile in 1-Dimension\nconst tile1D = (p: [times: number, width: number]) => {\n  const [times, width] = p;\n  const upper = Math.floor(times / 2);\n  const lower = -Math.floor(times / 2) + ((times + 1) % 2);\n  const f = (x: number) => x - width * clamp(Math.round(x / width), lower, upper);\n  // offset even numbers to keep centered after tiling\n  const offset = width / 2;\n  return (times % 2 === 1) ? f : (x: number) => f(x + offset);\n}\n\ntype TileParams = {\n  [a in Axis]?: [times: number, width: number]\n}\nconst identity = (n: number) => n;\nexport function tile(o: TileParams, s: Shape3): Shape3 {\n  const tileX = o.x ? tile1D(o.x) : identity;\n  const tileY = o.y ? tile1D(o.y) : identity;\n  const tileZ = o.z ? tile1D(o.z) : identity;\n  return wrap((p) => s([tileX(p[0]), tileY(p[1]), tileZ(p[2])]),\n    'float', 'vec3 p', [\n      `vec3 c = vec3(${f(o.x ? o.x[0] : 0)},${f(o.y ? o.y[0] : 0)},${f(o.z ? o.z[0] : 0)});`,\n      `vec3 m = vec3(${f(o.x ? o.x[1] : 0)},${f(o.y ? o.y[1] : 0)},${f(o.z ? o.z[1] : 0)});`,\n      `vec3 q = p-c*clamp(round(p/c),-m,m);`,\n      `return $1( q );`\n    ].join('\\n'), [s.gl]);\n}","import { clamp, Vector } from '../util/math';\nimport { extrude } from './extrude';\nimport { addFunc, f, v3 } from './glsl-util';\n\nexport function circle(r: number = 1): Shape2 {\n  const sp = (p: Vec2) => new Vector(p).magnitude() - r;\n  sp.gl = addFunc('float', 'vec2 p', `return length(p)-${f(r)};`, []);\n  return sp;\n}\n\nexport function sphere(r: number = 1): Shape3 {\n  const sp = (p: Vec3) => new Vector(p).magnitude() - r;\n  sp.gl = addFunc('float', 'vec3 p', `return length(p)-${f(r)};`, []);\n  return sp;\n}\n\nexport function cylinder(radius: number = 1, height = 2): Shape3 {\n  return extrude(height, circle(radius));\n}\n\nexport function rect(x: number = 2, y: number = x): Shape2 {\n  const x1 = x / 2, y1 = y / 2;\n  const sp = ([x, y]: Vec2) => {\n    const i = Math.max(Math.abs(x) - x1, 0);\n    const j = Math.max(Math.abs(y) - y1, 0);\n    const outside = new Vector([Math.max(i, 0), Math.max(j, 0)]).magnitude();\n    const inside = Math.min(Math.max(i, j), 0);\n    return outside + inside;\n  }\n  sp.gl = addFunc('float', 'vec2 p', [\n    `vec2 d = abs(p)-vec2(${f(x), f(y)});`,\n    `return length(max(d,0.0))+min(max(d.x,d.y),0.0); `\n  ].join('\\n'), []);\n  return sp;\n}\n\nconst poly2 = (points: Vec2[]): Shape2 => {\n  const sp = (p: Vec2) => {\n    const a = new Vector(p).minus(points[0]);\n    let distance = a.dot(a.result);\n    let sign = 1;\n    const len = points.length\n    for (let i = 0; i < len; i++) {\n      const i2 = (i + 1) % len;\n      const e = new Vector(points[i2]).minus(points[i]).result;\n      const v = new Vector(p).minus(points[i]).result;\n      const pq = new Vector(v).minus(new Vector(e).scale(clamp(\n        new Vector(v).dot(e) / new Vector(e).dot(e), 0, 1)).result);\n      distance = Math.min(distance, pq.dot(pq.result));\n\n      //winding number\n      const v2 = new Vector(p).minus(points[i2]).result;\n      const val3 = new Vector(e).cross2d(v);\n      const cond = [v[1] >= 0 ? 1 : 0, v2[1] < 0 ? 1 : 0, val3 > 0 ? 1 : 0];\n      if (Math.max(...cond) === Math.min(...cond)) {\n        sign *= -1;\n      }\n    }\n    return Math.sqrt(distance) * sign;\n  }\n  // from iq - https://www.shadertoy.com/view/WdSGRd\n  const poly = points.map(p => `vec2(${f(p[0]), f(p[1])})`).join(',');\n  sp.gl = addFunc('float', 'vec2 p', [\n    `vec2[N] poly = vec2[N](${poly})`,\n    `vec2[N] e;`,\n    `vec2[N] v;`,\n    `vec2[N] pq;`,\n    // data\n    `for( int i=0; i<N; i++) {`,\n    `    int i2= int(mod(float(i+1),float(N)));`, //i+1\n    `e[i] = poly[i2] - poly[i];`,\n    `    v[i] = p - poly[i];`,\n    `    pq[i] = v[i] - e[i]*clamp( dot(v[i],e[i])/dot(e[i],e[i]), 0.0, 1.0 );`,\n    `}`,\n    //distance\n    `float d = dot(pq[0], pq[0]); `,\n    `for( int i=1; i<N; i++) {`,\n    `  d = min( d, dot(pq[i], pq[i]));`,\n    `}`,\n    //winding number\n    // from http://geomalgorithms.com/a03-_inclusion.html\n    `int wn =0; `,\n    `for( int i=0; i<N; i++) {`,\n    `    int i2= int(mod(float(i+1),float(N)));`,\n    `    bool cond1= 0. <= v[i].y;`,\n    `    bool cond2= 0. > v[i2].y;`,\n    `    float val3= cross2d(e[i],v[i]);`, //isLeft\n    `    wn+= cond1 && cond2 && val3>0. ? 1 : 0;`, // have  a valid up intersect\n    `    wn-= !cond1 && !cond2 && val3<0. ? 1 : 0; // have  a valid down intersect`,\n    `}`,\n    `float s= wn == 0 ? 1. : -1.;`,\n    `return sqrt(d) * s;`,\n  ].join('\\n'), []);\n  return sp;\n}\n\n/**\n * @param points specify number of corners for a regular polygon.  Can also use an abitrary array of points\n * @param radius not required when using list of points\n */\nexport function poly(points: number | Vec2[], radius?: number): Shape2 {\n  const verts: Vec2[] = [];\n  if (typeof points === 'number') {\n    if (!radius) {\n      throw 'error: radius required unless explict Vec2[] is given for points';\n    }\n    verts.push([0, radius]);\n    const angle = 2 * Math.PI / points;\n    for (let i = 1; i < points; i++) {\n      const [x, y] = verts[i - 1];\n      const x1 = Math.cos(angle) * x - Math.sin(angle) * y;\n      const y1 = Math.sin(angle) * x + Math.cos(angle) * y;\n      verts.push([x1, y1]);\n    }\n  } else {\n    verts.push(...points);\n  }\n  if (verts.length < 3) {\n    throw 'error: polygon requires at least 3 points';\n  }\n  return poly2(verts);\n}\n\nexport function box(x: number = 2, y: number = x, z: number = y): Shape3 {\n  const x1 = x / 2, y1 = y / 2, z1 = z / 2;\n  const sp = ([x, y, z]: Vec3) => {\n    const i = Math.abs(x) - x1;\n    const j = Math.abs(y) - y1;\n    const k = Math.abs(z) - z1;\n    const outside = new Vector([Math.max(i, 0), Math.max(j, 0), Math.max(k, 0)]).magnitude();\n    const inside = Math.min(Math.max(i, j, k), 0);\n    return outside + inside;\n  }\n\n  sp.gl = addFunc('float', 'vec3 p', [\n    `vec3 q = abs(p) - ${v3([x, y, x])}; `,\n    `return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0); `\n  ].join('\\n'), []);\n  return sp;\n}\n\n","\r\nimport { union } from '../csg/boolean';\r\nimport { rotate, translate } from '../csg/manipulate';\r\nimport { box, sphere } from '../csg/primitives';\r\n\r\nexport const main = rotate('y', 15, rotate('z', 45,\r\n  union({ radius: 3 },\r\n    box(10.2),\r\n    translate([10, 10, 10], sphere(10)))));","import { Vector } from '../util/math';\r\nimport { initialState, setupWebGL, ShaderSrc, State } from './gl-util';\r\nimport { registerClickAndDrag, registerScrollWheel, SphericalSystem, sphericalToCartesion } from './mouse-orbit';\r\nimport { main } from './sample';\r\nimport { getShaderSrc } from '../csg/glsl-util';\r\ndeclare global {\r\n  interface Window { shaderSrc?: ShaderSrc; }\r\n}\r\nconst canvas = document.createElement(\"canvas\");\r\ncanvas.width = initialState.iResolution[0];\r\ncanvas.height = initialState.iResolution[1];\r\ndocument.body.append(canvas);\r\ncanvas.oncontextmenu = function (e) { e.preventDefault(); e.stopPropagation(); }\r\n\r\nconst shaderSrc: ShaderSrc = window.shaderSrc || getShaderSrc(main.gl);\r\nconst setState = setupWebGL(canvas, shaderSrc);\r\n\r\nlet orbitalState: SphericalSystem = {\r\n  pos: [300, Math.PI / 4, Math.PI / 4],\r\n  origin: [0, 0, 0]\r\n};\r\nconsole.log('initial state', JSON.stringify(initialState));\r\nlet state: State = { ...initialState, ...sphericalToCartesion(orbitalState) }\r\nconsole.log('new     state', JSON.stringify(state));\r\nsetState(state);\r\n\r\n\r\nregisterClickAndDrag(canvas, ({ current, startPos, end, leftClick }) => {\r\n  const screenX = (current[0] - startPos[0]) / initialState.iResolution[0];\r\n  const screenY = (current[1] - startPos[1]) / initialState.iResolution[1];\r\n  const tmp: SphericalSystem = { ...orbitalState };\r\n  if (leftClick) {\r\n    // rotate\r\n    const pos = orbitalState.pos;\r\n    tmp.pos = [\r\n      pos[0],\r\n      pos[1] + screenX * 5,\r\n      pos[2] + screenY * 5\r\n    ];\r\n  } else {\r\n    // pan\r\n    const origin = orbitalState.origin;\r\n    const deltaY = new Vector(state.cameraTop).scale(screenY).result;\r\n    const deltaX = new Vector(state.cameraTop).cross(state.cameraDir).scale(screenX).result;\r\n    const delta = new Vector(deltaX).add(deltaY).scale(orbitalState.pos[0] / 10).result;\r\n    tmp.origin = new Vector(origin).add(delta).result;\r\n  }\r\n  const _state = { ...state, ...sphericalToCartesion(tmp) };\r\n  if (end) {\r\n    orbitalState = tmp;\r\n    state = _state;\r\n  }\r\n  window.requestAnimationFrame(() => {\r\n    setState(_state);\r\n  });\r\n});\r\n\r\nregisterScrollWheel(canvas, (zoom) => {\r\n  const tmp = { ...orbitalState };\r\n  tmp.pos[0] += Math.sign(zoom) * Math.max(tmp.pos[0] / 10, 1);\r\n  orbitalState = tmp;\r\n  state = { ...state, ...sphericalToCartesion(tmp) };\r\n  window.requestAnimationFrame(() => {\r\n    setState(state);\r\n  });\r\n});"]}